{"main":"let sequencer = {\n    ac: null,\n    seqs: [],\n    init: function() {\n        this.ac = new(window.AudioContext || window.webkitAudioContext);\n    },\n    play: function(melody) {\n        if(this.seqs.length)\n            return;\n        if(this.ac===null)\n            this.init();\n        let tempo = 132;\n        let seq = new TinyMusic.Sequence(this.ac, tempo, melody);\n        seq.loop = true;\n        seq.waveType = 'triangle';\n        seq.staccato = 0.8;\n        seq.volume = 0.7;\n        seq.attack = 0.05;\n        seq.decay = 0.05;\n        seq.sustain = 0.5;\n        seq.release = 0.1;\n        seq.play();\n        this.seqs.push(seq);\n    },\n    isPlaying: function() {\n        return this.seqs.length > 0;\n    },\n    stop: function() {\n        this.seqs.forEach((element) => { element.stop(); });\n        this.seqs.length = 0;\n    }\n};\n\nlet melody = app.getResource('melody.json');\n\nfunction createButton(innerHTML, style, callback) {\n    let btn = document.createElement('button');\n    btn.innerHTML = innerHTML;\n    if(style) for(let key in style)\n        btn.style[key] = style[key];\n    btn.addEventListener('click', callback);\n    return btn;\n}\n\nlet btn = createButton(\n    'PLAY',\n    {\n        position:\"absolute\",\n        width:\"100px\",\n        height:\"50px\",\n        left:\"calc(50% - 50px)\",\n        top:\"calc(50% - 25px)\"\n    },\n    function() {\n        if(sequencer.isPlaying()) {\n            sequencer.stop();\n            this.innerHTML = 'PLAY';\n        }\n        else {\n            sequencer.play(melody);\n            this.innerHTML = 'STOP';\n        }        \n    }\n);\napp.addHTMLLayer(100).appendChild(btn);\n","resources":{"melody.json":{"resource":"[\n\t\"C3 q\",\n\t\"C3 q\",\n\t\"Bb2 e\",\n\t\"C3 e\",\n\t\"C3 e\",\n\t\"Bb2 e\"\n]","mime":"application/json"},"TinyMusic.js":{"resource":"(function ( root, factory ) {\n  if ( typeof define === 'function' && define.amd ) {\n    define( [ 'exports' ], factory );\n  } else if ( typeof exports === 'object' && typeof exports.nodeName !== 'string' ) {\n    factory( exports );\n  } else {\n    factory( root.TinyMusic = {} );\n  }\n}( this, function ( exports ) {\n\n/*\n * Private stuffz\n */\n\nvar enharmonics = 'B#-C|C#-Db|D|D#-Eb|E-Fb|E#-F|F#-Gb|G|G#-Ab|A|A#-Bb|B-Cb',\n  middleC = 440 * Math.pow( Math.pow( 2, 1 / 12 ), -9 ),\n  numeric = /^[0-9.]+$/,\n  octaveOffset = 4,\n  space = /\\s+/,\n  num = /(\\d+)/,\n  offsets = {};\n\n// populate the offset lookup (note distance from C, in semitones)\nenharmonics.split('|').forEach(function( val, i ) {\n  val.split('-').forEach(function( note ) {\n    offsets[ note ] = i;\n  });\n});\n\n/*\n * Note class\n *\n * new Note ('A4 q') === 440Hz, quarter note\n * new Note ('- e') === 0Hz (basically a rest), eigth note\n * new Note ('A4 es') === 440Hz, dotted eighth note (eighth + sixteenth)\n * new Note ('A4 0.0125') === 440Hz, 32nd note (or any arbitrary\n * divisor/multiple of 1 beat)\n *\n */\n\n// create a new Note instance from a string\nfunction Note( str ) {\n  var couple = str.split( space );\n  // frequency, in Hz\n  this.frequency = Note.getFrequency( couple[ 0 ] ) || 0;\n  // duration, as a ratio of 1 beat (quarter note = 1, half note = 0.5, etc.)\n  this.duration = Note.getDuration( couple[ 1 ] ) || 0;\n}\n\n// convert a note name (e.g. 'A4') to a frequency (e.g. 440.00)\nNote.getFrequency = function( name ) {\n  var couple = name.split( num ),\n    distance = offsets[ couple[ 0 ] ],\n    octaveDiff = ( couple[ 1 ] || octaveOffset ) - octaveOffset,\n    freq = middleC * Math.pow( Math.pow( 2, 1 / 12 ), distance );\n  return freq * Math.pow( 2, octaveDiff );\n};\n\n// convert a duration string (e.g. 'q') to a number (e.g. 1)\n// also accepts numeric strings (e.g '0.125')\n// and compund durations (e.g. 'es' for dotted-eight or eighth plus sixteenth)\nNote.getDuration = function( symbol ) {\n  return numeric.test( symbol ) ? parseFloat( symbol ) :\n    symbol.toLowerCase().split('').reduce(function( prev, curr ) {\n      return prev + ( curr === 'w' ? 4 : curr === 'h' ? 2 :\n        curr === 'q' ? 1 : curr === 'e' ? 0.5 :\n        curr === 's' ? 0.25 : 0 );\n    }, 0 );\n};\n\n/*\n * Sequence class\n */\n\n// create a new Sequence\nfunction Sequence( ac, tempo, arr ) {\n  this.tempo = tempo || 120;\n  this.loop = true;\n  this.smoothing = 0;\n  this.staccato = 0;\n  this.notes = [];\n  this.push.apply( this, arr || [] );\n\n  this.volume = 1;\n  this.attack = 0;\n  this.decay = 0;\n  this.sustain = 1;\n  this.release = 0;\n\n  this.ac = ac || new AudioContext();\n  this.createFxNodes();\n}\n\n// create gain and EQ nodes, then connect 'em\nSequence.prototype.createFxNodes = function() {\n  var eq = [ [ 'bass', 100 ], [ 'mid', 1000 ], [ 'treble', 2500 ] ],\n    prev = this.gain = this.ac.createGain();\n  eq.forEach(function( config, filter ) {\n    filter = this[ config[ 0 ] ] = this.ac.createBiquadFilter();\n    filter.type = 'peaking';\n    filter.frequency.value = config[ 1 ];\n    prev.connect( prev = filter );\n  }.bind( this ));\n  prev.gain.value = this.volume;\n  prev.connect( this.ac.destination );\n  return this;\n};\n\n// accepts Note instances or strings (e.g. 'A4 e')\nSequence.prototype.push = function() {\n  Array.prototype.forEach.call( arguments, function( note ) {\n    this.notes.push( note instanceof Note ? note : new Note( note ) );\n  }.bind( this ));\n  return this;\n};\n\n// create a custom waveform as opposed to \"sawtooth\", \"triangle\", etc\nSequence.prototype.createCustomWave = function( real, imag ) {\n  // Allow user to specify only one array and dupe it for imag.\n  if ( !imag ) {\n    imag = real;\n  }\n\n  // Wave type must be custom to apply period wave.\n  this.waveType = 'custom';\n\n  // Reset customWave\n  this.customWave = [ new Float32Array( real ), new Float32Array( imag ) ];\n};\n\n// recreate the oscillator node (happens on every play)\nSequence.prototype.createOscillator = function() {\n  this.stop();\n  this.osc = this.ac.createOscillator();\n\n  // customWave should be an array of Float32Arrays. The more elements in\n  // each Float32Array, the dirtier (saw-like) the wave is\n  if ( this.customWave ) {\n    this.osc.setPeriodicWave(\n      this.ac.createPeriodicWave.apply( this.ac, this.customWave )\n    );\n  } else {\n    this.osc.type = this.waveType || 'square';\n  }\n\n  this.osc.connect( this.gain );\n  return this;\n};\n\n// schedules this.notes[ index ] to play at the given time\n// returns an AudioContext timestamp of when the note will *end*\nSequence.prototype.scheduleNote = function( index, when ) {\n  var duration = 60 / this.tempo * this.notes[ index ].duration,\n    cutoff = duration * ( 1 - ( this.staccato || 0 ) );\n\n  this.setFrequency( this.notes[ index ].frequency, when );\n  if ( this.smoothing && this.notes[ index ].frequency ) {\n    this.slide( index, when, cutoff );\n  }\n\n  if(this.attack>0) {\n    this.gain.gain.setValueAtTime(0, when);\n    this.gain.gain.linearRampToValueAtTime(this.volume, when+this.attack);\n  }\n  else\n    this.gain.gain.setValueAtTime(this.volume, when);\n  if(this.sustain<1) {\n    this.gain.gain.linearRampToValueAtTime(this.sustain*this.volume, when+this.attack+this.decay);\n  }\n  if(this.release>0) {\n    this.gain.gain.linearRampToValueAtTime(0, when + cutoff + this.release);\n    this.setFrequency( 0, when + cutoff + this.release );\n  }\n  else\n    this.setFrequency( 0, when + cutoff );\n  return when + duration;\n};\n\n// get the next note\nSequence.prototype.getNextNote = function( index ) {\n  return this.notes[ index < this.notes.length - 1 ? index + 1 : 0 ];\n};\n\n// how long do we wait before beginning the slide? (in seconds)\nSequence.prototype.getSlideStartDelay = function( duration ) {\n  return duration - Math.min( duration, 60 / this.tempo * this.smoothing );\n};\n\n// slide the note at <index> into the next note at the given time,\n// and apply staccato effect if needed\nSequence.prototype.slide = function( index, when, cutoff ) {\n  var next = this.getNextNote( index ),\n    start = this.getSlideStartDelay( cutoff );\n  this.setFrequency( this.notes[ index ].frequency, when + start );\n  this.rampFrequency( next.frequency, when + cutoff );\n  return this;\n};\n\n// set frequency at time\nSequence.prototype.setFrequency = function( freq, when ) {\n  this.osc.frequency.setValueAtTime( freq, when );\n  return this;\n};\n\n// ramp to frequency at time\nSequence.prototype.rampFrequency = function( freq, when ) {\n  this.osc.frequency.linearRampToValueAtTime( freq, when );\n  return this;\n};\n\n// run through all notes in the sequence and schedule them\nSequence.prototype.play = function( when ) {\n  when = typeof when === 'number' ? when : this.ac.currentTime;\n\n  this.createOscillator();\n  this.osc.start( when );\n\n  this.notes.forEach(function( note, i ) {\n    when = this.scheduleNote( i, when );\n  }.bind( this ));\n\n  this.osc.stop( when );\n  this.osc.onended = this.loop ? this.play.bind( this, when ) : null;\n\n  return this;\n};\n\n// stop playback, null out the oscillator, cancel parameter automation\nSequence.prototype.stop = function() {\n  if ( this.osc ) {\n    this.osc.onended = null;\n    this.osc.disconnect();\n    this.osc = null;\n  }\n  return this;\n};\n\n  exports.Note = Note;\n  exports.Sequence = Sequence;\n}));\n","mime":"application/x-javascript","terms":"The MIT License (MIT)\n\nCopyright (c) 2014 Kevin Ennis\n\nEnvelope handling 2019 by eludi.net\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"}}}